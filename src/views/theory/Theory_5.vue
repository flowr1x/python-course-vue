<template>
  <div class="manual__text text-manual">
    <div class="text-manual__header">
      <h1 class="text-manual__title">Тема 5</h1>
      <div class="text-manual__subtitle">Логические выражения и операторы</div>
    </div>
    <div class="text-manual__body">
      <div class="text-manual__content">
        <section class="text-manual__doc-section">
            <h2 id="title1" class="text-manual__section-title">Логические выражения и логический тип данных</h2>
            <div class="text-manual__section-block">
              <p>Часто в реальной жизни мы соглашаемся с каким-либо утверждением или отрицаем его.
                  Например, если вам скажут, что сумма чисел 3 и 5 больше 7, вы согласитесь, скажете: «Да,
                  это правда». Если же кто-то будет утверждать, что сумма трех и пяти меньше семи, то вы
                  расцените такое утверждение как ложное.</p>
              <p>Подобные фразы предполагают только два возможных ответа – либо "да", когда выражение
                  оценивается как правда, истина, либо "нет", когда утверждение оценивается как ошибочное,
                  ложное. В программировании и математике <b>если результатом вычисления выражения 
                  может быть лишь истина или ложь, то такое выражение называется логическим.</b></p>
              <p>Например, выражение 4 > 5 является логическим, так как его результатом является либо
                  правда, либо ложь. Выражение 4 + 5 не является логическим, так как результатом его
                  выполнения является число.</p>
              <p>На позапрошлом уроке мы познакомились с тремя типами данных – целыми и
                  вещественными числами, а также строками. Сегодня введем четвертый – <b>логический тип
                  данных</b> (тип bool). Его также называют булевым. У этого типа всего два возможных
                  значения: <b>True</b> (правда) и <b>False</b> (ложь).</p>
              <pre><code class="python">>>> a = True
>>> type(a)
&lt;class 'bool'&gt;
>>> b = False
>>> type(b)
&lt;class 'bool'&gt;</code></pre>
              <p>Здесь переменной a было присвоено значение True, после чего с помощью встроенной в
                  Python функции type() проверен ее тип. Интерпретатор сообщил, что это переменная класса
                  bool. Понятия «класс» и «тип данных» в данном случае одно и то же. Переменная b также
                  связана с булевым значением.</p>
              <p>В программировании False обычно приравнивают к нулю, а True – к единице. Чтобы в этом
                  убедиться, можно преобразовать булево значение к целочисленному типу:</p>
              <pre><code class="python">>>> int(True)
1
>>> int(False)
0</code></pre>
              <p>Возможно и обратное. Можно преобразовать какое-либо значение к булевому типу:</p>
              <pre><code class="python">>>> bool(3.4)
True
>>> bool(-150)
True
>>> bool(0)
False
>>> bool(' ')
True
>>> bool('')
False
</code></pre>
              <p>И здесь работает правило: всё, что не 0 и не пустота, является правдой.</p>
            </div> 
        </section>
        <section class="text-manual__doc-section">
            <h2 id="title2" class="text-manual__section-title">Логические операторы</h2>
            <div class="text-manual__section-block">
              <p>Говоря на естественном языке (например, русском) мы обозначаем сравнения словами
                  "равно", "больше", "меньше". В языках программирования используются специальные знаки,
                  подобные тем, которые используются в математике: > (больше), &lt;(меньше), >= (больше или
                  равно), &lt;= (меньше или равно), == (равно), != (не равно).</p>
              <p>Не путайте операцию присваивания значения переменной, обозначаемую в языке Python
                  одиночным знаком "равно", и операцию сравнения (два знака "равно"). Присваивание и
                  сравнение – разные операции.</p>
              <pre><code class="python">>>> a = 10
>>> b = 5
>>> a + b > 14
True
>>> a &lt; 14 - b
False
>>> a &lt;= b + 5
True
>>> a != b
True
>>> a == b
False
>>> c = a == b
>>> a, b, c
(10, 5, False)</code></pre>
              <p>В данном примере выражение c = a == b состоит из двух подвыражений. Сначала
                  происходит сравнение (==) переменных a и b. После этого результат логической операции
                  присваивается переменной c. Выражение a, b, c просто выводит значения переменных на
                  экран.</p>
            </div>
        </section>
        <section class="text-manual__doc-section">
            <h2 id="title3" class="text-manual__section-title">Сложные логические выражения</h2>
            <div class="text-manual__section-block">
              <p>Логические выражения типа kByte >= 1023 являются простыми, так как в них выполняется
                  только одна логическая операция. Однако, на практике нередко возникает необходимость в
                  более сложных выражениях. Может понадобиться получить ответа "Да" или "Нет" в
                  зависимости от результата выполнения двух простых выражений. Например, "на улице идет
                  снег или дождь", "переменная news больше 12 и меньше 20".</p>
              <p>В таких случаях используются специальные операторы, объединяющие два и более простых
                  логических выражения. Широко используются два оператора – так называемые логические И
                  (<b>and</b>) и ИЛИ (<b>or</b>).</p>
              <p>Чтобы получить <b>True</b> при использовании оператора <b>and</b>, необходимо, чтобы результаты
                  обоих простых выражений, которые связывает данный оператор, были истинными. Если хотя
                  бы в одном случае результатом будет <b>False</b>, то и все сложное выражение будет ложным.</p>
              <p>Чтобы получить <b>True</b> при использовании оператора <b>or</b>, необходимо, чтобы результат хотя бы
                  одного простого выражения, входящего в состав сложного, был истинным. В случае
                  оператора <b>or</b> сложное выражение становится ложным лишь тогда, когда ложны оба
                  составляющие его простые выражения.</p>
              <p>Допустим, переменной x было присвоено значение 8 (x = 8), переменной y присвоили 13 (y
                  = 13). Логическое выражение y &lt; 15 and x > 8 будет выполняться следующим образом.
                  Сначала выполнится выражение y &lt; 15. Его результатом будет True. Затем выполнится
                  выражение x > 8. Его результатом будет False. Далее выражение сведется к True and
                  False, что вернет False.</p>
              <pre><code class="python">>>> x = 8
>>> y = 13
>>> y &lt; 15 and x > 8
False</code></pre>
              <p>Если бы мы записали выражение так: x > 8 and y &lt; 15, то оно также вернуло бы False.
                  Однако сравнение y &lt; 15 не выполнялось бы интерпретатором, так как его незачем
                  выполнять. Ведь первое простое логическое выражение (x > 8) уже вернуло ложь, которая, в
                  случае оператора and, превращает все выражение в ложь</p>
              <p>В случае с оператором or второе простое выражение проверяется, если первое вернуло ложь,
                  и не проверяется, если уже первое вернуло истину. Так как для истинности всего выражения
                  достаточно единственного True, неважно по какую сторону от or оно стоит.</p>
              <pre><code class="python">>>> y &lt; 15 or x > 8
True</code></pre>
              <p>В языке Python есть еще унарный логический оператор <b>not</b>, т. е. отрицание. Он превращает
                  правду в ложь, а ложь в правду. Унарный он потому, что применяется к одному выражению,
                  стоящему после него, а не справа и слева от него как в случае бинарных and и or.</p>
              <pre><code class="python">>>> not y &lt; 15
False</code></pre>
              <p>Здесь у &lt; 15 возвращает True. Отрицая это, мы получаем False.</p>
              <pre><code class="python">>>> a = 5
>>> b = 0
>>> not a
False
>>> not b
True
</code></pre>
              <p>Число 5 трактуется как истина, отрицание истины дает ложь. Ноль приравнивается к False.
                  Отрицание False дает True.</p>
            </div>
        </section>
      </div>
    </div>              
  </div>
</template>

<script>
export default {
  name: "theory_5"
}
</script>
