<template>
  <div class="manual__text text-manual">
    <div  class="text-manual__header">
      <h1 class="text-manual__title">Тема 7</h1>
      <div class="text-manual__subtitle">Ошибки и исключения. Обработка исключений</div>
    </div>
    <div class="text-manual__body">
      <div class="text-manual__content">
        <div class="content-inner">
          <section  class="text-manual__doc-section">
            <h2 class="text-manual__section-title">Ошибки и исключения</h2>
            <div class="text-manual__section-block">
              <p>В любой, особенно большой, программе могут возникать ошибки, приводящие к ее
                  неработоспособности или к тому, что программа делает не то, что должна. Причин
                  возникновения ошибок много.</p>
              <p>Программист может сделать ошибку в употреблении самого языка программирования.
                  Другими словами, выразиться так, как выражаться не положено. Например, начать имя
                  переменной с цифры или забыть поставить двоеточие в заголовке сложной инструкции.
                  Подобные ошибки называют <b>синтаксическими</b>, они нарушают синтаксис и пунктуацию
                  языка. Интерпретатор Питона, встретив ошибочное выражение, не знает как его
                  интерпретировать. Поэтому останавливает выполнение программы и выводит
                  соответствующее сообщение, указав на место возникновения ошибки:</p>
              <pre><code class="python">>>> 1a = 10
File "&lt;stdin&gt;", line 1
1a = 10
^
SyntaxError: invalid syntax</code></pre>
              <p>В терминологии языка Python здесь возникло исключение, принадлежащее классу
                  SyntaxError. Согласно документации Python синтаксические ошибки все4таки принято
                  относить к ошибкам, а все остальные – к исключениям. В некоторых языках
                  программирования не используется слово "исключение", а ошибки делят на синтаксические
                  и семантические. Нарушение семантики обычно означает, что, хотя выражения написаны
                  верно с точки зрения синтаксиса языка, программа не работает так, как от нее ожидалось.
                  Для сравнения. Вы можете грамотным русским языком сказать несколько предложений, но по
                  смыслу это будет белиберда, или вас поймут не так, как хотелось бы.</p>
              <p>В Python не говорят о семантических ошибках, говорят об <b>исключениях</b>. Их множество. В
                  этом уроке мы рассмотрим некоторые из них, в последующих встретимся с еще несколькими.</p>
              <p>Если вы попытаетесь обратиться к переменной, которой не было присвоено значение, что в
                  случае Python означает, что переменная вообще не была объявлена, она не существует, то
                  возникнет исключение NameError</p>
              <pre><code class="python">>>> a = 0
>>> print(a + b)
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'b' is not defined</code></pre>
              <p>Последнюю строку сообщения можно перевести как "Ошибка имени: имя 'b' не определено".</p>
              <p>Если исключение возникает при выполнении кода из файла, то вместо "line 1" будет указана
                  строка, в которой оно возникло, например, "line 24". Вместо "&lt;stdin&gt;" будет указано имя
                  файла, например, "test.py". В данном же случае stdin обозначает стандартный поток ввода.
                  По4умолчанию это поток ввода с клавиатуры. Строка 1 – потому что в интерактивном режиме
                  каждое выражение интерпретируется отдельно, как обособленная программка. Если написать
                  выражение, состоящее из нескольких строк, то линия возникновения ошибки может быть
                  другой:</p>
              <pre><code class="python">>>> a = 0
>>> if a == 0:
... print(a)
... print(a + b)
...
0
Traceback (most recent call last):
 File "&lt;stdin&gt;", line 3, in &lt;module&gt;
NameError: name 'b' is not defined</code></pre>
              <p>Следующие два исключения, о которых следует упомянуть, и с которыми вы уже могли
                  встретиться в предыдущих уроках, это ValueError и TypeError – ошибка значения и ошибка
                  типа.</p>
              <pre><code class="python">>>> int("Hi")
Traceback (most recent call last):
 File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: invalid literal for int() with base 10: 'Hi'
>>> 8 + "3"
Traceback (most recent call last):
 File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for +: 'int' and 'str'</code></pre>
              <p>В примере строку "Hi" нельзя преобразовать к целому числу. Возникает исключение
                  ValueError, потому что функция int() не может преобразовать такое значение.</p>
              <p>Число 8 и строка "3" принадлежат разным типам, операнд сложения между которыми не
                  поддерживается. При попытке их сложить возникает исключение TypeError.</p>
              <p>Деление на ноль вызывает исключение ZeroDivisionError:</p>
              <pre><code class="python">>>> 1/0
Traceback (most recent call last):
 File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ZeroDivisionError: division by zero</code></pre>
            </div> 
          </section>
          <section  class="text-manual__doc-section">
            <h2 class="text-manual__section-title">Обработка исключений. Оператор try-except</h2>
            <div class="text-manual__section-block">
              <p>Когда ошибки в программе возникают в процессе написания кода или его тестирования, то
                  код исправляется программистом так, чтобы ошибок не возникало. Однако нередко действия
                  пользователя приводят к тому, что в программе возникает исключение. Например, программа
                  ожидает ввод числа, но человек ввел букву. Попытка преобразовать ее к числу приведет к
                  возбуждению исключения ValueError, и программа аварийно завершится.</p>
              <p>На этот случай в языках программирования, в том числе Python, существует специальный
                  оператор, позволяющий перехватывать возникающие исключения и обрабатывать их так,
                  чтобы программа продолжала работать или корректно завершала свою работу.</p>
              <p>В Питоне такой перехват выполняет оператор try4except. "Try" переводится как "попытаться",
                  "except" – как исключение. Словами описать его работу можно так: "Попытаться сделать то4
                  то и то4то, если при этом возникло исключение, то сделать вот это и это." Его конструкция
                  похожа на условный оператор с веткой else. Рассмотрим пример:</p>
              <pre><code class="python">n = input("Введите целое число: ")
try:
 n = int(n)
 print("Удачно")
except:
 print("Что-то пошло не так")</code></pre>
              <p>Исключительная ситуация может возникнуть в третьей строчке кода, когда значение
                  переменной n преобразуется к целому числу. Если это невозможно, то дальнейшее
                  выполнение выражений в теле try прекращается. В данном случае выражение print("Удачно")
                  выполнено не будет. При этом поток выполнения программы перейдет на ветку except и
                  выполнит ее тело.</p>
              <p><b>Если в теле try исключения не возникает, то тело ветки except не выполняется.</b></p>
              <p>Вот пример вывода программы, когда пользователь вводит целое число:</p>
              <pre><code class="python">Введите целое число: 100
Удачно</code></pre>
              <p>А здесь – когда вводит не то, что ожидалось:</p>
              <pre><code class="python">Введите целое число: AA
Что-то пошло не так</code></pre>
              <p>Есть одна проблема. Код выше обработает любое исключение. Однако в теле try могут
                  возникать разные исключения, и у каждого из них должен быть свой обработчик. Поэтому
                  более правильным является указание типа исключения после ключевого слова except.</p>
              <pre><code class="python">try:
 n = input('Введите целое число: ')
 n = int(n)
 print("Все нормально. Вы ввели число", n)
except ValueError:
 print("Вы ввели не целое число")</code></pre>
              <p>Теперь если сработает тело except мы точно знаем, из4за чего возникла ошибка. Но если в
                  теле try возникнет еще какое4нибудь исключение, то оно не будет обработано. Для него надо
                  написать отдельную ветку except. Рассмотрим программу:</p>
              <pre><code class="python">try:
 a = float(input("Введите делимое: "))
 b = float(input("Введите делитель: "))
 c = a / b
 print("Частное: %.2f" % c)
except ValueError:
 print("Нельзя вводить строки")
except ZeroDivisionError:
 print("Нельзя делить на ноль")</code></pre>
              <p>При ее выполнении исключения могут возникнуть в трех строчках кода: где происходит
                  преобразование введенных значений к вещественным числам и в месте, где происходит
                  деление. В первом случае может возникнуть ValueError, во втором – ZeroDivisionError.
                  Каждый тип исключения обрабатывается своей веткой except.</p>
              <p>Несколько исключений можно сгруппировать в одну ветку и обработать совместно:</p>
              <pre><code class="python">try:
 a = float(input("Введите делимое: "))
 b = float(input("Введите делитель: "))
 c = a / b
 print("Частное: %.2f" % c)
except (ValueError, ZeroDivisionError):
 print("Нельзя вводить строки или делить на ноль")</code></pre>
              <p>У оператора обработки исключений, кроме except, могут быть еще ветки finally и else (не
                  обязательно обе сразу). Тело <b>finally выполняется всегда</b>, независимо от того, выполнялись
                  ли блоки except в ответ на возникшие исключения или нет. Тело <b>lse сработает, если
                  исключений в try не было</b>, т. е. не было переходов на блоки except.</p>
              <pre><code class="python">try:
 n = input('Введите целое число: ')
 n = int(n)
except ValueError:
 print("Вы что-то попутали с вводом")
else: # выполняется, когда в блоке try не возникло исключения
 print("Все нормально. Вы ввели число", n)
finally: # выполняется в любом случае
 print("Конец программы")
</code></pre>
              <p>Примечание. В данном коде используются комментарии. В языке Python перед ними ставится
                  знак решетки #. Комментарии в программном коде пишутся исключительно для человека и
                  игнорируются интерпретатором или компилятором.</p>
              <p>Посмотрите, как выполняется программа в случае возникновения исключения и без этого:</p>
              <pre><code class="python">pl@pl-desk:~$ python3 test.py
Введите целое число: 4.3
Вы что-то попутали с вводом
Конец программы
pl@pl-desk:~$ python3 test.py
Введите целое число: 4
Все нормально. Вы ввели число 4
Конец программы</code></pre>
              <p>В данном уроке изложены не все особенности обработки исключений. Так в более крупных
                программах, содержащих несколько уровней вложенности кода, функции, модули и классы,
                исключения могут обрабатываться не по месту их возникновения, а передаваться дальше по
                иерархии вызовов.</p>
              <p>Также исключение может возникнуть в блоке except, else или finally, и тогда им нужен
                собственный обработчик. Модифицируем немного предыдущую программу и специально
                сгенерируем исключение в теле except:</p>
              <pre><code class="python">try:
 n = input('Введите целое число: ')
 n = int(n)
except ValueError:
 print("Вы что-то попутали с вводом")
 3 / 0
except ZeroDivisionError:
 print("Деление на ноль")
else:
 print("Все нормально. Вы ввели число", n)
finally:
 print("Конец программы")
</code></pre>
              <p>По началу может показаться, что все нормально. Исключение, генерируемое выражением 3 /
                0 будет обработано веткой except ZeroDivisionError. Однако это не так. Эта ветка
                обрабатывает только исключения, возникающие в блоке try, к которому она сама относится.
                Вот вывод программы, если ввести не целое число:</p>
              <pre><code class="python">Введите целое число: а
Вы что-то попутали с вводом
Конец программы
Traceback (most recent call last):
 File "test.py", line 15, in &lt;module&gt;
  n = int(n)
ValueError: invalid literal for int() with base 10: 'а'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
 File "test.py", line 18, in &lt;module&gt;
  3 / 0
ZeroDivisionError: division by zero</code></pre>
              <p>Мало того, что не было обработано деление на ноль, поскольку тело except ValueError
                  неудачно завершилось, само исключение ValueError посчиталось необработанным. Решение
                  проблемы может быть, например, таким:</p>
              <pre><code class="python">…
except ValueError:
 print("Вы что-то попутали с вводом")
 try:
  3 / 0
 except ZeroDivisionError:
  print("Деление на ноль")
…</code></pre>
              <p>Здесь в тело except вложен свой внутренний обработчик исключений.</p>
          </div>
          </section>
        </div>
      </div>
    </div>              
  </div>
</template>
