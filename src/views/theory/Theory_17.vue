<template>
  <div class="manual__text text-manual">
    <div class="text-manual__header">
      <h1 class="text-manual__title">Тема 17</h1>
      <div class="text-manual__subtitle">Цикл for</div>
    </div>
    <div class="text-manual__body">
      <section class="text-manual__doc-section">
        <h2 id="title1" class="text-manual__section-title">Определение цикла for</h2>
        <div class="text-manual__section-block">
        <p>Цикл for в языке программирования Python предназначен для перебора элементов структур
          данных и некоторых других объектов. Это не цикл со счетчиком, каковым является for во
          многих других языках.</p>
        <p>Что значит перебор элементов? Например, у нас есть список, состоящий из ряда элементов.
          Сначала берем из него первый элемент, затем второй, потом третий и так далее. С каждым
          элементом мы выполняем одни и те же действия в теле for. Нам не надо извлекать элементы
          по их индексам и заботится, на каком из них список заканчивается, и следующая итерация
          бессмысленна. Цикл for сам переберет и определит конец.</p>
        <pre><code class="python">>>> spisok = [10, 40, 20, 30]
>>> for element in spisok:
... print(element + 2)
...
12
42
22
32</code></pre>
        <p>После ключевого слова for используется переменная под именем element. Имя здесь может
          быть любым. Нередко используют i. На каждой итерации цикла for ей будет присвоен
          очередной элемент из списка spisok. Так при первой прокрутке цикла идентификатор
          element связан с числом 10, на второй – с числом 40, и так далее. Когда элементы в spisok
          заканчиваются, цикл for завершает свою работу.</p>
        <p>С английского "for" переводится как "для", "in" как "в". Перевести конструкцию с языка
          программирования на человеческий можно так: для каждого элемента в списке делать
          следующее (то, что в теле цикла).</p>
        <p>В примере мы увеличивали каждый элемент на 2 и выводили его на экран. При этом сам
          список конечно же не изменялся:</p>
        <pre><code class="python">>>> spisok
[10, 40, 20, 30]</code></pre>
        <p>Нигде не шла речь о перезаписи его элементов, они просто извлекались и использовались.
          Однако бывает необходимо изменить сам список, например, изменить значение каждого
          элемента в нем или только определенных, удовлетворяющих определенному условию. И тут
          без переменной, обозначающей индекс элемента, в большинстве случаев не обойтись:</p>
        <pre><code class="python">>>> i = 0
>>> for element in spisok:
... spisok[i] = element + 2
... i += 1
...
>>> spisok
[12, 42, 22, 32]</code></pre>
        <p>Но если мы вынуждены использовать счетчик, то выгода от использования цикла for не
          очевидна. Если знать длину списка, то почему бы не воспользоваться while. Длину можно
          измерить с помощью встроенной в Python функции len().</p>
        <pre><code class="python">>>> i = 0
>>> while i &lt; len(spisok):
...     spisok[i] = spisok[i] + 2 # или spisok[i] += 2
...     i = i + 1 # или i += 1
...
>>> spisok
[14, 44, 24, 34]</code></pre>
        <p>Кроме того, с циклом while мы избавились от переменной element. </p>
      </div>
      </section>
      <section  class="text-manual__doc-section">
        <h2 id="title2" class="text-manual__section-title">Функция range()</h2>
        <div class="text-manual__section-block">
          <p>Теперь пришло время познакомиться со встроенной в Python функцией range(). "Range"
            переводится как "диапазон". Она может принимать один, два или три аргумента. Их
            назначение такое же как у функции randrange() из модуля random. Если задан только один, то
            генерируются числа от 0 до указанного числа, не включая его. Если заданы два, то числа
            генерируются от первого до второго, не включая его. Если заданы три, то третье число – это
            шаг.</p>
          <p>Однако, в отличие от randrange(), функция range() генерирует не одно случайное число в
            указанном диапазоне. Она вообще не генерирует случайные числа. Она генерирует
            последовательность чисел в указанном диапазоне. Так, range(5, 11) сгенерирует
            последовательность 5, 6, 7, 8, 9, 10. Однако это будет не структура данных типа "список".
            Функция range() производит объекты своего класса – диапазоны:</p>
          <pre><code class="python">>>> a = range(-10, 10)
>>> a
range(-10, 10)
>>> type(a)
&lt;class 'range'&gt;</code></pre>
          <p>Несмотря на то, что мы не видим последовательности чисел, она есть, и мы можем
            обращаться к ее элементам:</p>
          <pre><code class="python">>>> a[0]
-10
>>> a[5]
-5
>>> a[15]
5
>>> a[-1]
9</code></pre>
          <p>Хотя изменять их нельзя, так как, в отличие от списков, объекты range() относятся к группе
            неизменяемых:</p>
          <pre><code class="python">>>> a[10] = 100
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'range' object does not support item assignment</code></pre>
        </div> 
      </section>
      <section  class="text-manual__doc-section">
        <h2 id="title3" class="text-manual__section-title">Цикл for и range()</h2>
        <div class="text-manual__section-block">
          <p>Итак, зачем нам понадобилась функций range() в теме про цикл for? Дело в том, что вместе
            они образуют неплохой тандем. For как цикл перебора элементов, в отличие от while,
            позволяет не следить за тем, достигнут ли конец структуры. Не надо вводить счетчик для
            этого, изменять его и проверять условие в заголовке. С другой стороны, range() дает
            последовательность целых чисел, которые можно использовать как индексы для элементов
            того же списка. </p>
          <pre><code class="python">>>> range(len(spisok))
range(0, 4)</code></pre>
          <p>Здесь с помощью функции len() измеряется длина списка. В данном случае она равна
            четырем. После этого число 4 передается в функцию range(), и она генерирует
            последовательность чисел от 0 до 3 включительно. Это как раз индексы элементов нашего
            списка.</p>
          <p>Теперь "соединим" for и range():</p>
          <pre><code class="python">>>> for i in range(len(spisok)):
...     spisok[i] += 2
...
>>> spisok
[16, 46, 26, 36]</code></pre>
          <p>В заголовке цикла for берутся элементы вовсе не списка, а объекта range. Список, элементы
              которого планируется перезаписывать, тут по-сути не фигурирует. Если заранее знать длину
              списка, то заголовок может выглядеть так: for i in range(4). То, как используется i в теле
              цикла, вопрос второй. Примечание. Вместо идентификатора i может быть любой другой.</p>
        </div>
      </section>
      <section class="text-manual__doc-section">
        <h2 id="title4" class="text-manual__section-title">Функция enumerate()</h2>
        <div class="text-manual__section-block">
          <p>В Python есть еще одна встроенная функция, которая часто используется в заголовке for. Это
            функция enumerate(). Если range() позволяет получить только индексы элементов списка, то
            enumerate() генерирует пары кортежей, состоящих из индекса элемента и значения элемента</p>
          <pre><code class="python">>>> spisok = [16, 46, 26, 36]
>>> for i in enumerate(spisok):
...     print(i)
...
(0, 16)
(1, 46)
(2, 26)
(3, 36)</code></pre>
          <p>Эти кортежи можно распаковывать, то есть извлекать индекс и значение, в теле цикла:</p>
          <pre><code class="python">>>> for item in enumerate(spisok):
...     print(item[0], item[1])
...
0 16
1 46
2 26
3 36</code></pre>
          <p>Однако чаще это делают еще в заголовке for, используя две переменные перед in:</p>
          <pre><code class="python">>>> for id, val in enumerate(spisok):
...     print(id, val)
...
0 16
1 46
2 26
3 36</code></pre>
          <p>Если функция enumerate() так хороша, зачем использовать range() в заголовке for? На самом
            деле незачем, если только вам так не проще. Кроме того, бывают ситуации, когда значения не
            нужны, нужны только индексы. Однако следует учитывать один нюанс. Функция enumerate()
            возвращает так называемый объект-итератор. Когда такие объекты сгенерировали значения,
            то становятся "пустыми". Второй раз по ним пройтись нельзя.</p>
          <p>Функция range() возвращает итерируемый объект. Хотя такой объект может быть превращен
            в итератор, сам по себе таковым не является.</p>
          <p>Когда range() и enumerate() используются в заголовке for, то разницы нет, так как range и
            enumerate-объекты не присваиваются переменным и после завершения работы цикла
            теряются. Но если мы присваиваем эти объекты переменным, разница есть:</p>
          <pre><code class="python">>>> r_obj = range(len(spisok))
>>> e_obj = enumerate(spisok)
>>> for i in r_obj:
...     if i == 1:
...         break
...
>>> for i in e_obj:
...     if i[0] == 1:
...         break
...
>>> for i in r_obj:
...     print(i)
...
0
1
2
3
>>> for i in e_obj:
...     print(i)
... 
(2, 26)
(3, 36)</code></pre>
            <p>Сначала мы прерываем извлечение элементов из объектов на элементе с индексом 1. Когда
                снова прогоняем объекты через цикл for, то в случае r_obj обход начинается сначала, а в
                случае e_obj продолжается после места останова. Объект e_obj уже не содержит извлеченных
                ранее элементов.</p>
        </div>
      </section>
    </div>         
  </div>
</template>
<script>
export default {
  name: "theory_17"
}
</script>
