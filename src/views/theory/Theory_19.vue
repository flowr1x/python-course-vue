<template>
  <div class="manual__text text-manual">
    <div class="text-manual__header">
      <h1 class="text-manual__title">Тема 19</h1>
      <div class="text-manual__subtitle">Кортеж</div>
    </div>
    <div class="text-manual__body">
      <section  class="text-manual__doc-section">
        <h2 id="title1" class="text-manual__section-title">Определение</h2>
        <div class="text-manual__section-block">
          <p>Кортежи (tuple) в Python – это те же списки за одним исключением. Кортежи неизменяемые
            структуры данных. Так же как списки они могут состоять из элементов разных типов,
            перечисленных через запятую. Кортежи заключаются в круглые, а не квадратные скобки.</p>
          <pre><code class="python">>>> a = (10, 2.13, "square", 89, 'C')
    >>> a
    (10, 2.13, 'square', 89, 'C')</code></pre>
          <p>Из кортежа можно извлекать элементы и брать срезы:</p>
          <pre><code class="python">>>> a[3]
    89
    >>> a[1:3]
    (2.13, 'square')</code></pre>
          <p>Однако изменять его элементы нельзя:</p>
          <pre><code class="python">>>> a[0] = 11
    Traceback (most recent call last):
      File "&gt;stdin&lt;", line 1, in &gt;module&lt;
    TypeError: 'tuple' object does not support item assignment</code></pre>
          <p>Также у типа tuple нет методов для добавления и удаления элементов.</p>
          <p>Возникает резонный вопрос. Зачем в язык программирования был введен этот тип данных,
            по-сути представляющий собой неизменяемый список? Дело в том, что иногда надо
            защитить список от изменений. Преобразовать же кортеж в список, если это потребуется, как
            и выполнить обратную операцию легко с помощью встроенных в Python функций list() и
            tuple():</p>
          <pre><code class="python">>>> a = (10, 2.13, "square", 89, 'C')
    >>> b = [1, 2, 3]
    >>> c = list(a)
    >>> d = tuple(b)
    >>> c
    [10, 2.13, 'square', 89, 'C']
    >>> d
    (1, 2, 3)</code></pre>
          <p>Рассмотрим случай, когда уместно использовать кортежи. В Python изменяемые объекты
            передаются в функцию по ссылке. Это значит, что не создается копия объекта, а переменной4
            параметру присваивается ссылка на уже существующий объект. В итоге, если в теле функции
            объект изменяется, то эти изменения касаются глобального объекта.</p>
        <pre><code class="python">def addNum(seq, num):
    for i in range(len(seq)):
        seq[i] += num
    return seq
    
    origin = [3, 6, 2, 6]
    changed = addNum(origin, 3)
    
    print(origin)
    print(changed)</code></pre>
          <p>Данная программа неправильная. Хотя никаких выбросов исключений не произойдет, она 
            содержит логическую ошибку. На выводе получаем:
          </p>
          <pre><code class="python">[6, 9, 5, 9]
[6, 9, 5, 9]</code></pre>
          <p>То есть исходный список был также изменен. Параметр seq содержал ссылку не на свой 
            локальный список, а на список4оригинал. Таким образом, в операторе return здесь нет смыла. 
            Если функция замысливалась как изменяющая глобальный список, то программа должна 
            выглядеть так:
          </p>
          <pre><code class="python">def addNum(seq, num):
 for i in range(len(seq)):
 seq[i] += num
 
origin = [3, 6, 2, 6]
addNum(origin, 3)
print(origin)</code></pre>
          <p>Что делать, если все же требуется не изменять исходный список, а сформировать по нему 
            новый. Задачу можно решить несколькими способами. Во первых, в функции можно создать 
            локальный список, после чего возвращать его:
          </p>
          <pre><code class="python">def addNum(seq, num):
 new_seq = []
 for i in seq:
 new_seq.append(i + num)
 return new_seq
 
origin = [3, 6, 2, 6]
changed = addNum(origin, 3)
print(origin)
print(changed)</code></pre>
          <p>Результат:</p>
          <pre><code class="python">[3, 6, 2, 6]
[6, 9, 5, 9]</code></pre>
          <p>Исходный список в функции не меняется. Его элементы лишь перебираются.</p>
          <p>Второй способ защитить список4оригинал – использовать кортеж. Этот способ более 
            надежный, так как в больших программах трудно отследить, что ни одна функция не 
            содержит команд изменения глобальных данных. </p>
          <p>Хотя преобразовывать к кортежу можно как при передаче в функцию, так и в самой функции,
            лучше сразу делать глобальный список кортежем. Поскольку неизменяемые объекты 
            передаются по значению, а не по ссылке, то в функцию будет поступать копия структуры, а 
            не оригинал. Даже если туда передается оригинал, изменить его невозможно. Можно лишь, 
            как вариант, скопировать его и/или изменить тип, создав тем самым локальную структуру, и 
            делать с ней все, что заблагорассудится. </p>
          <pre><code class="python">def addNum(seq, num):
 seq = list(seq)
 for i in range(len(seq)):
 seq[i] += num
 return seq
 
origin = (3, 6, 2, 6)
changed = addNum(origin, 3)
print(origin)
print(changed)</code></pre>
        </div> 
      </section>
      <section  class="text-manual__doc-section">
        <h2 id="title2" class="text-manual__section-title">Списки в кортежах</h2>
        <div class="text-manual__section-block">
          <p>Кортежи могут содержать списки, также как списки быть вложенными в другие списки.</p>
          <pre><code class="python">>>> nested = (1, "do", ["param", 10, 20])</code></pre>
          <p>Как вы думаете, можем ли мы изменить список [a; b]."param", 10, 20] вложенный в кортеж nested? 
            Список изменяем, кортеж – нет. Если вам кажется, что нельзя, то вам кажется неправильно. 
            На самом деле можно:</p>
          <pre><code class="python">>>> nested[2][1] = 15
>>> nested
(1, 'do', ['param', 15, 20])</code></pre>
          <p>Примечание. Выражения типа nested[a; b].2][a; b].1] используются для обращения к вложенным 
            объектам. Первый индекс указывает на позицию вложенного объекта, второй – индекс 
            элемента внутри вложенного объекта. Так в данном случае сам список внутри кортежа имеет 
            индекс 2, а элемент списка 10 – индекс 1 в списке.</p>
          <p>Странная ситуация. Кортеж неизменяем, но мы все4таки можем изменить его. На самом деле 
            кортеж остается неизменяемым. Просто в нем содержится не сам список, а ссылка на него. 
            Ее изменить нельзя. Но менять сам список можно.
          </p>
          <p>Чтобы было проще понять, перепишем кортеж так:</p>
          <pre><code class="python">>>> l = ["param", 10, 20]
>>> t = (1, "do", l)
>>> t
(1, 'do', ['param', 10, 20])</code></pre>
          <p>Кортеж содержит переменную4ссылку. Поменять ее на другую ссылку нельзя. Но кортеж не 
            содержит самого списка. Поэтому его можно менять как угодно:
          </p>
          <pre><code class="python">>>> l.pop(0)
'param'
>>> t
(1, 'do', [10, 20])
</code></pre>
          <p>Однако помните, такой номер не прокатывает с неизменяемыми типами:</p>
          <pre><code class="python">>>> a = "Kat"
>>> t = (a, l)
>>> t
('Kat', [10, 20])
>>> a = "Bat"
>>> t
('Kat', [10, 20])
</code></pre>
          <p>Они передаются в кортеж как и в функцию – по значению. Т. е. их значение копируется в 
            момент передачи.
          </p>
        </div>
      </section>
    </div>          
  </div>
</template>
<script>
export default {
  name: "theory_19"
}
</script>

