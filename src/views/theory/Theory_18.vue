<template>
  <div class="manual__text text-manual">
    <div class="text-manual__header">
      <h1 class="text-manual__title">Тема 18</h1>
      <div class="text-manual__subtitle">Строки</div>
    </div>
    <div class="text-manual__body">
      <section  class="text-manual__doc-section">
        <h2 class="text-manual__section-title">Определение</h2>
        <div class="text-manual__section-block">
          <p>Мы уже рассматривали строки как простой тип данных наряду с целыми и вещественными
              числами и знаем, что строка – это последовательность символов, заключенных в одинарные
              или двойные кавычки.</p>
          <p>В Python нет символьного типа, т. е. типа данных, объектами которого являются одиночные
              символы. Однако язык позволяет рассматривать строки как объекты, состоящие из подстрок
              длинной в один и более символов. При этом, в отличие от списков, строки не принято
              относить к структурам данных. Видимо потому, что структуры данных состоят из более
              простых типов данных, а для строк в Python нет более простого (символьного) типа.</p>
          <p>С другой стороны, строка, как и список, – это упорядоченная последовательность элементов.
              Следовательно, из нее можно извлекать отдельные символы и срезы</p>
          <pre><code class="python">>>> s = "Hello, World!"
    >>> s[0]
    'H'
    >>> s[7:]
    'World!'
    >>> s[::2]
    'Hlo ol!'</code></pre>
          <p>В последнем случае извлечение идет с шагом, равным двум, т. е. извлекается каждый второй
              символ. Примечание. Извлекать срезы с шагом также можно из списков.</p>
          <p>Важным отличием от списков является неизменяемость строк в Python. Нельзя перезаписать
              какой4то отдельный символ или срез в строке:</p>
          <pre><code class="python">>>> s[-1] = '.'
    Traceback (most recent call last):
     File "&lt;stdin&gt;", line 1, in &lt;module&gt;
    TypeError: 'str' object does not support item assignment</code></pre>
          <p>Интерпретатор сообщает, что объект типа str не поддерживает присвоение элементам.</p>
          <p>Если требуется изменить строку, то следует создать новую из срезов старой:</p>
          <pre><code class="python">>>> s = s[0:-1] + '.'
    >>> s
    'Hello, World.'</code></pre>
          <p>В примере берется срез из исходной строки, соединяется с другой строкой. Получается новая
              строка, которая присваивается переменной s. Ее старое значение при этом теряется. </p>
        </div> 
      </section>
      <section  class="text-manual__doc-section">
        <h2 class="text-manual__section-title">Методы строк</h2>
        <div class="text-manual__section-block">
          <p>В Python для строк есть множество методов. Посмотреть их можно по команде dir(str),
            получить информацию по каждому – help(str.имя_метода). Рассмотрим наиболее интересные
            из них.</p>
          <h3>Методы split() и join()</h3>
          <p>Метод split() позволяет разбить строку по пробелам. В результате получается список слов.
            Если пользователь вводит в одной строке ряд слов или чисел, каждое из которых должно в
            программе обрабатываться отдельно, то без split() не обойтись</p>
          <pre><code class="python">>>> s = input()
red blue orange white
>>> s
'red blue orange white'
>>> sl = s.split()
>>> sl
['red', 'blue', 'orange', 'white']
>>> s
'red blue orange white'</code></pre>
          <p>Список, возвращенный методом split(), мы могли бы присвоить той же переменной s, т. е. s =
            s.split(). Тогда исходная строка была бы потеряна. Если она не нужна, то лучше не вводить
            дополнительную переменную.</p>
          <p>Метод split() может принимать необязательный аргумент-строку, указывающей по какому
            символу или подстроке следует выполнить разделение:</p>
          <pre><code class="python">>>> s.split('e')
['r', 'd blu', ' orang', ' whit', '']
>>> '40030023'.split('00')
['4', '3', '23']</code></pre>
          <p>Метод строк join() выполняет обратное действие. Он формирует из списка строку. Поскольку
            это метод строки, то впереди ставится строка4разделитель, а в скобках — передается список:</p>
          <pre><code class="python">>>> '-'.join(sl)
'red-blue-orange-white'</code></pre>
          <p>Если разделитель не нужен, то метод применяется к пустой строке:</p>
          <pre><code class="python">>>> ''.join(sl)
'redblueorangewhite'</code></pre>
          <h3>Методы find() и replace()</h3>
          <p>Данные методы строк работают с подстроками. Методы find() ищет подстроку в строке и
            возвращает индекс первого элемента найденной подстроки. Если подстрока не найдена, то
            возвращает -1.</p>
          <pre><code class="python">>>> s
'red blue orange white'
>>> s.find('blue')
4
>>> s.find('green')
-1</code></pre>
          <p>Поиск может производиться не во всей строке, а лишь на каком4то ее отрезке. В этом случае
            указывается первый и последний индексы отрезка. Если последний не указан, то ищется до
            конца строки:</p>
          <pre><code class="python">>>> letters = 'ABCDACFDA'
>>> letters.find('A', 3)
4
>>> letters.find('DA', 0, 6)
3</code></pre>
          <p>Здесь мы ищем с третьего индекса и до конца, а также с первого и до шестого. Обратите
            внимания, что метод find() возвращает только первое вхождение. Так выражение
            letters.find('A', 3) последнюю букву 'A' не находит, так как 'A' ему уже встретилась под
            индексом 4.</p>
          <p>Метод replace() заменяет одну подстроку на другую:</p>
          <pre><code class="python">>>> letters.replace('DA', 'NET')
'ABCNETCFNET'</code></pre>
          <p>Исходная строка, конечно, не меняется:</p>
          <pre><code class="python">>>> letters
'ABCDACFDA'</code></pre>
          <p>Так что если результат надо сохранить, то его надо присвоить переменной:</p>
          <pre><code class="python">>>> new_letters = letters.replace('DA', 'NET')
>>> new_letters
'ABCNETCFNET'</code></pre>
          <h3>Метод format()</h3>
          <p>Строковый метод format() уже упоминался при рассмотрении вывода на экран с помощью
            функции print():</p>
          <pre><code class="python">>>> print("This is a {0}. It's {1}.".format("ball", "red"))
This is a ball. It's red.</code></pre>
          <p>Однако к print() он никакого отношения не имеет, а применяется к строкам. Лишь потом
            заново сформированная строка передается в функцию вывода.</p>
          <p>Возможности format() широкие, рассмотрим основные.</p>
          <pre><code class="python">>>> size1 = "length - {}, width - {}, height - {}"
>>> size1.format(3, 6, 2.3)
'length - 3, width - 6, height — 2.3'</code></pre>
          <p>Если фигурные скобки исходной строки пусты, то подстановка аргументов идет согласно
            порядку их следования. Если в фигурных скобках строки указаны индексы аргументов,
            порядок подстановки может быть изменен:</p>
          <pre><code class="python">>>> size2 = "height - {2}, length - {0}, width - {1}"
>>> size2.format(3, 6, 2.3)
'height - 2.3, length - 3, width - 6'</code></pre>
          <p>Кроме того, аргументы могут передаваться по слову-ключу:</p>
          <pre><code class="python">>>> info = "This is a {subj}. It's {prop}."
>>> info.format(subj="table", prop="small")
"This is a table. It's small."</code></pre>
          <p>Пример форматирования вещественных чисел:</p>
          <pre><code class="python">>>> "{1:.2f} {0:.3f}".format(3.33333, 10/6)
'1.67 3.333'</code></pre>
        </div>
      </section>        
    </div>     
  </div>
</template>
